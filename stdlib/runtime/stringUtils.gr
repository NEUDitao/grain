// TODO(#1050): Remove dependency on Pervasives once Option/Result types are imbedded in the compiler

import WasmI32, {
  add as (+),
  sub as (-),
  gtU as (>),
  geU as (>=),
  ltU as (<),
  shrS as (>>),
  eq as (==),
  ne as (!=),
  and as (&),
} from "runtime/unsafe/wasmi32"
import WasmI64 from "runtime/unsafe/wasmi64"
import Memory from "runtime/unsafe/memory"
import Tags from "runtime/unsafe/tags"
import BI from "runtime/bigint"
import { reducedInteger } from "runtime/numbers"
import { get_POWERS10, get_POWERS10_FAST_PATH, get_POWERS5 } from "runtime/numberUtils"

// temporary until everything is implemented
import Exception from "runtime/exception"
primitive throw: Exception -> a = "@throw"

@unsafe
let _MINIMUM_EXPONENT_32 = 23n
@unsafe
let _MIN_EXPONENT_ROUND_TO_EVEN_64 = -4N
@unsafe
let _MIN_EXPONENT_ROUND_TO_EVEN_32 = -17n
@unsafe
let _MAX_EXPONENT_ROUND_TO_EVEN_64 = -23N
@unsafe
let _MAX_EXPONENT_ROUND_TO_EVEN_32 = 10n
@unsafe
let _MIN_EXPONENT_FAST_PATH_64 = -22N
@unsafe
let _MAX_EXPONENT_FAST_PATH_64 = 22N
@unsafe
let _MAX_EXPONENT_DISGUISED_FAST_PATH_64 = 37N
@unsafe
let _MAX_MANTISSA_FAST_PATH_64 = 2N << 52N
@unsafe
let _MANTISSA_EXPLICIT_BITS_64 = 63N
@unsafe
let _MANTISSA_EXPLICIT_BITS_32 = 23n
@unsafe
let _INFINITE_POWER_64 = 0x7FFN
@unsafe
let _SMALLEST_POWER_OF_TEN_64 = -342N
@unsafe
let _LARGEST_POWER_OF_TEN_64 = 308N
@unsafe
let _SMALLEST_POWER_OF_FIVE_64 = -342N
@unsafe
let _LARGEST_POWER_OF_FIVE_64 = 308N

@unsafe
let getPowers10 = (i: WasmI32) => {
  WasmI32.load(get_POWERS10(), 4n * i)
}

@unsafe
let getPowers10FastPath = (i: WasmI32) => {
  WasmI64.load(get_POWERS10_FAST_PATH(), 8n * i)
}

@unsafe
let getPowers5 = (i: WasmI32) => {
  let n = 8n * i
  (
    WasmI64.load(get_POWERS10_FAST_PATH(), n),
    WasmI64.load(get_POWERS10_FAST_PATH(), n + 8n)
  )
}

// https://stdrs.dev/nightly/x86_64-unknown-linux-gnu/src/core/num/dec2flt/common.rs.html#165
@unsafe
let is8Digits = (value: WasmI64) => {
  let (-) = Wasmi64.sub
  let (|) = WasmI64.or
  let (&) = Wasmi64.and
  let (==) = Wasmi64.eq

  let a = value - 0x4646_4646_4646_4646N
  let b = value - 0x3030_3030_3030_3030N
  let c = (a | b) & 0x8080_8080_8080_8080N

  c == 0N
}

// Try to parse 8 digits at a time:
// https://johnnylee-sde.github.io/Fast-numeric-string-to-int/
@unsafe
let parse8Digits = (value: WasmI64) => {
  let (+) = Wasmi64.add
  let (-) = Wasmi64.sub
  let (*) = WasmI64.mul
  let (>>) = WasmI64.shrU
  let (&) = Wasmi64.and
  let (|) = WasmI64.or
  let (==) = Wasmi64.eq

  let _MASK = 0x0000_00FF_0000_00FFN

  let a = digits - 0x3030_3030_3030_3030N
  let b = (a * 10N) + (a >> 8N)
  let c = (b & _MASK) * 0x000F_4240_0000_0064N
  let d = ((b >> 16N) & _MASK) * 0x0000_2710_0000_0001N

  ((c + d) >> 32N)
}

@unsafe
let parseScientificExponent = (ptr: WasmI32, offset: WasmI32, len: WasmI32) => {
  let mut exponent = 0N
  let mut negative = false
  let mut i = offset

  // Parse the optional leading sign
  match (WasmI32.load8U(ptr, i)) {
    fst when fst == _CHAR_PLUS => {
      offset = 1n
      negative = false
    }
    fst when fst == _CHAR_MINUS => {
      offset = 1n
      negative = true
    }
    _ => break
  }

  if (i >= len) {
    Err("Invalid exponent")
  } else {
    // Parse digits '0'-'9' until we hit a non-digit byte or reach the end of the string
    while (i < len - 1) {
      let digit = WasmI32.load8U(ptr, i) - 0x30n
      if (digit >= 0n && digit < 10n) {
        if (WasmI64.lt(exponent, 0x10000N)) {
          exponent = WasmI64.add(WasmI64.extendI32U(digit), WasmI64.mul(10N, exponent))
        }
        i += 1n
      } else {
        break
      }
    }
    if (i != len) {
      Err("Invalid exponent")
    } else if (negative) {
      Ok(-exponent)
    } else {
      Ok(exponent)
    }
  }
}

// From Rust:
// Calculate a base 2 exponent from a decimal exponent.
// This uses a pre-computed integer approximation for
// log2(10), where 217706 / 2^16 is accurate for the
// entire range of non-finite decimal exponents.
@unsafe
let power = (q: WasmI32) => {
  (q * (152170n + 65536n) >> 16n) + 63n
}

@unsafe
let fullMultiplication = (a: WasmI64, b: WasmI64) => {
  let c = WasmI32.fromGrain(BI.mul(BI.makeWrappedUint64(a) * BI.makeWrappedUint64(b)))
  let lo = WasmI64.load(c, 16n)
  let d = BI.shrS(c, 64n)
  let hi = WasmI64.load(d, 16n)
  Memory.free(c)
  Memory.free(d)
  (lo, hi)
}

// From Rust:
// This will compute or rather approximate w * 5**q and return a pair of 64-bit words
// approximating the result, with the "high" part corresponding to the most significant
// bits and the low part corresponding to the least significant bits.
@unsafe
let computeProductApprox = (q: WasmI64, w: WasmI64, precision: WasmI64) => {
  let (==) = WasmI64.eq
  let (&) = WasmI64.and
  let (>) = WasmI64.gt
  let (>=) = WasmI64.gte
  let (<=) = WasmI64.lte
  let (>>) = WasmI64.shrU
  let (-) = WasmI64.sub
  let (+) = WasmI64.add
  
  assert q >= _SMALLEST_POWER_OF_FIVE
  assert q <= _LARGEST_POWER_OF_FIVE
  assert precision <= 64N

  let mask = if (precision < 64N) {
    0xFFFF_FFFF_FFFF_FFFFN >> precision
  } else {
    0xFFFF_FFFF_FFFF_FFFFN
  }

  // From Rust:
  // 5^q < 2^64, then the multiplication always provides an exact value.
  // That means whenever we need to round ties to even, we always have
  // an exact value.
  let index = q - _SMALLEST_POWER_OF_FIVE
  let (lo5, hi5) = getPowers5(WasmI32.wrapI64(index))
  
  // From Rust:
  // Only need one multiplication as long as there is 1 zero but
  // in the explicit mantissa bits, +1 for the hidden bit, +1 to
  // determine the rounding direction, +1 for if the computed
  // product has a leading zero.
  let mut (firstLo, firstHi) = fullMultiplication(w, lo5)
  if ((firstHi & mask) == mask) {
    // From Rust:
    // Need to do a second multiplication to get better precision
    // for the lower product. This will always be exact
    // where q is < 55, since 5^55 < 2^128. If this wraps,
    // then we need to need to round up the hi product.
    let (_, secondHi) = fullMultiplication(w, hi5)
    firstLo = firstLo + secondHi
    if (secondHi > firstLo) {
      firstHi += 1N;
    }
  }
  
  (firstLo, firstHi)
}

// Returns the significant bits and a biased binary exponent that can be directly shifted into exponent bits:
// (u64, i32)
@unsafe
let computeFloat = (exponent: WasmI64, mantissa: WasmI64) => {
  let (==) = WasmI64.eq
  let (<) = WasmI64.lt
  let (<=) = WasmI64.lte
  let (>) = WasmI64.gt
  let (>=) = WasmI64.gte
  let (<<) = WasmI64.shl
  let (>>) = WasmI64.shrU
  let (&) = WasmI64.and
  let (+) = WasmI64.add
  
  let fpZero = (0N, 0n)
  let fpInf = (0N, _INFINITE_POWER)

  let w = mantissa
  let q = exponent  
  
  if (w == 0N || q < _SMALLEST_POWER_OF_TEN) {
    Ok(fpZero)
  } else if (q > _LARGEST_POWER_OF_TEN) {
    Ok(fpInf)
  } else {
    let lz = WasmI64.clz(w)
    let w = w << lz
    let (lo, hi) = computeProductApprox(q, w, _MANTISSA_EXPLICIT_BITS + 3N)
    // From Rust:
    // If we have failed to approximate w x 5^-q with our 128-bit value.
    // Since the addition of 1 could lead to an overflow which could then
    // round up over the half-way point, this can lead to improper rounding
    // of a float.
    //
    // However, this can only occur if q âˆˆ [-27, 55]. The upper bound of q
    // is 55 because 5^55 < 2^128, however, this can only happen if 5^q > 2^64,
    // since otherwise the product can be represented in 64-bits, producing
    // an exact result. For negative exponents, rounding-to-even can
    // only occur if 5^-q < 2^64.
    //
    // For detailed explanations of rounding for negative exponents, see
    // <https://arxiv.org/pdf/2101.11408.pdf#section.9.1>. For detailed
    // explanations of rounding for positive exponents, see
    // <https://arxiv.org/pdf/2101.11408.pdf#section.8>.
    match (lo == 0xFFFF_FFFF_FFFF_FFFFN && !((q >= -27N) && (q <= 55N)))) {
      true => Err("Cannot compute float")
      false => {
        let upperbit = WasmI32.wrapI64(hi >> 63N)
        let mut mantissa = hi >> WasmI64.extendI32S({
          let (+) = WasmI32.add
          let (-) = WasmI32.sub
          upperbit + 64n - _MANTISSA_EXPLICIT_BITS_32 - 3n
        })
        let mut power2 = {
          let (+) = WasmI32.add
          let (-) = WasmI32.sub
          let q = WasmI32.wrapI64(q)
          let lz = WasmI32.wrapI64(lz)
          power(q) + upperbit - lz - _MINIMUM_EXPONENT_32
        }
        if (WasmI32.lte(power2, 0n)) {
          // -power2 + 1 >= 64
          if (WasmI32.gte(WasmI32.add(WasmI32.mul(-1n, power2), 1n), 64n)) {
            // Have more than 64 bits below the minimum exponent, must be 0.
            Ok(fpZero)
          } else {
            // Have a subnormal value.
            mantissa = mantissa >> WasmI64.extendI32S(
              // -power2 + 1
              WasmI32.add(WasmI32.mul(-1n, power2), 1n)
            )
            mantissa += mantissa & 1N
            mantissa = mantissa >> 1N
            power2 = if (mantissa >= (1N << MANTISSA_EXPLICIT_BITS_64)) {
              1n
            } else {
              0n
            }
            Ok((mantissa, power2))
          }
        } else {
          // Need to handle rounding ties. Normally, we need to round up,
          // but if we fall right in between and and we have an even basis, we
          // need to round down.
          //
          // This will only occur if:
          //  1. The lower 64 bits of the 128-bit representation is 0.
          //      IE, 5^q fits in single 64-bit word.
          //  2. The least-significant bit prior to truncated mantissa is odd.
          //  3. All the bits truncated when shifting to mantissa bits + 1 are 0.
          //
          // Or, we may fall between two floats: we are exactly halfway.
          if (
            lo <= 1N &&
            q >= _MIN_EXPONENT_ROUND_TO_EVEN_64 &&
            q <= _MAX_EXPONENT_ROUND_TO_EVEN_64 &&
            (mantissa & 3N == 1N) &&
            ((mantissa << WasmI64.extendI32S({
                let (+) = WasmI32.add
                let (-) = WasmI32.sub
                upperbit + 64n - _MANTISSA_EXPLICIT_BITS_32 - 3n
              })) == hi)
          ) {
            // Zero the lowest bit, so we don't round up.
            // mantissa &= !1N;
            mantissa = mantissa & WasmI64.xor(1N, 0xffffffffffffffff);
          }
          // Round-to-even, then shift the significant digits into place.
          mantissa += mantissa & 1;
          mantissa >>= 1;
          if mantissa >= (2_u64 << F::MANTISSA_EXPLICIT_BITS) {
              // Rounding up overflowed, so the carry bit is set. Set the
              // mantissa to 1 (only the implicit, hidden bit is set) and
              // increase the exponent.
              mantissa = 1_u64 << F::MANTISSA_EXPLICIT_BITS;
              power2 += 1;
          }
          // Zero out the hidden bit.
          mantissa &= !(1_u64 << F::MANTISSA_EXPLICIT_BITS);
          if power2 >= F::INFINITE_POWER {
              // Exponent is above largest normal value, must be infinite.
              return fp_inf;
          }
          BiasedFp { f: mantissa, e: power2 }
        }
      }
    }
  }
}

@unsafe
let parseFloatToParts = (string: String) => {
  let _CHAR_MINUS = 0x2dn
  let _CHAR_PLUS = 0x2bn
  let _CHAR_DOT = 0x2en
  let _CHAR_0 = 0x30n
  let _CHAR_E = 0x65n
  let _CHAR_e = 0x45n

  let ptr = WasmI32.fromGrain(string)
  match (WasmI32.load(ptr, 4n)) {
    // Invalid string
    len when len == 0n => Err("Invalid string"),
    // Continue to parse the string
    len => {
      let mut i = 8n
      let mut mantissa = 0N
      let mut exponent = 0n
      let mut numDigits = 0n
      let mut numDigitsAfterDot = 0n
      let mut manyDigits = false

      // Parse the optional leading sign
      let mut negative = false
      let mut offset = 0n
      match (WasmI32.load8U(ptr, i)) {
        fst when fst == _CHAR_PLUS => {
          offset = 1n
          negative = false
        }
        fst when fst == _CHAR_MINUS => {
          offset = 1n
          negative = true
        }
        _ => break
      }

      // Parse digits '0'-'9' until we hit a non-digit byte or reach the end of the string
      while (i < len - 1) {
        let digit = WasmI32.load8U(ptr, i) - _CHAR_0
        if (digit >= 0n && digit < 10n) {
          mantissa = WasmI64.add(WasmI64.mul(mantissa, 10N), WasmI64.extendI32U(digit))
          numDigits += 1n
          i += 1n
        } else {
          break
        }
      }

      // Handle the dot
      match (WasmI32.load8U(ptr, i)) {
        c => c when c == _CHAR_DOT => {
          i += 1n
          let dotStartIndex = i
          // Parse chunks of 8 digits
          while (i + 8n <= len) {
            let digits = WasmI64.load(ptr, i)
            if (is8Digits(digits)) {
              mantissa = WasmI64.add(parse8Digits(digits), WasmI64.mul(mantissa, 100000000N))
              i += 8n
            }
          }
          // Parse digits '0'-'9' until we hit a non-digit byte or reach the end of the string
          while (i < len - 1) {
            let digit = WasmI32.load8U(ptr, i) - _CHAR_0
            if (digit >= 0n && digit < 10n) {
              mantissa = WasmI64.add(WasmI64.extendI32U(digit), WasmI64.mul(mantissa, 10N))
              i += 1n
            } else {
              break
            }
          }
          numDigitsAfterDot = i - dotStartIndex
          exponent = -numDigitsAfterDot
        },
        _ => break
      }

      numDigits += numDigitsAfterDot

      match (numDigits) {
        // Maybe someone tried to parse junk or an invalid JSON float like "Infinity" or "NaN"?
        n => n == 0n => Err("Invalid float"),
        // We're still good...
        _ => {
          let _MAX_MANTISSA_DIGITS = 19n // 10^19 fits in uint64
          let _MIN_19DIGIT_INT = 100_0000_0000_0000_0000N

          // Parse scientific notation
          let exponentResult = match (WasmI32.load8U(ptr, i)) {
            c when c == _CHAR_E || c == _CHAR_e => {
              i += 1n
              parseScientificExponent(ptr, i, len)
            },
            _ => Ok(0N)
          }

          // Hopefully, exponent parsing went alright
          match (exponentResult) {
            Ok(exponentNumber) => {
              exponent += exponentNumber

              // Check to see if we have to go down the slow path
              if (numDigits > _MAX_MANTISSA_DIGITS) {
                manyDigits = false
                numDigits -= _MAX_MANTISSA_DIGITS
                i = 8n + offset
                while (i < len - 1) {
                  let c = WasmI32.load8U(ptr, i)
                  if (c == _CHAR_DOT || c == _CHAR_0) {
                    let n = (c - (_CHAR_0 - 1n))
                    numDigits -= if (n < 0n) { 0n } else if (n > 255n) { 255n } else { n }
                    i += 1n
                  } else {
                    break
                  }
                }

                if (numDigits > 0n) {
                  manyDigits = true
                  mantissa = 0N
                  throw Exception.AssertionError("parsing > 19 digit floats unimplemented")
                  exponent = if (WasmI64.gte(mantissa, _MIN_19DIGIT_INT)) {
                    throw Exception.AssertionError("bigint float parsing unimplemented")
                  } else {
                    // From Rust: https://github.com/Alexhuszagh/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/library/core/src/num/dec2flt/parse.rs#L179-L184
                    // the next byte must be present and be '.'
                    // We know this is true because we had more than 19
                    // digits previously, so we overflowed a 64-bit integer,
                    // but parsing only the integral digits produced less
                    // than 19 digits. That means we must have a decimal
                    // point, and at least 1 fractional digit.
                    i += 1n
                    throw Exception.AssertionError("parsing > 19 digit floats unimplemented")
                  }
                  // Add back the explicit part
                  exponent += exponentNumber
                }
              }

              if (i != len) {
                // Didn't parse the entire string
                Err("Invalid float")
              } else {
                Ok((exponent, mantissa, negative, manyDigits))
              }
            },
            // Exponent parsing failed
            err => err
          }
        }
      }
    }
  }
}

@unsafe
export let isFastPath = (exponent: WasmI64, mantissa: WasmI64, negative: Bool, manyDigits: Bool) => {
  let (<=) = WasmI64.lte
  let (<<) = WasmI64.shl

  _MIN_EXPONENT_FAST_PATH <= exponent &&
  exponent <= _MAX_EXPONENT_DISGUISED_FAST_PATH &&
  mantissa <= _MAX_MANTISSA_FAST_PATH &&
  !manyDigits
}

@unsafe
export let parseFloat = (string: String) => {
  match (parseFloatToParts(string)) {
    Ok((exponent, mantissa, negative, numDigits)) => {
      let value = if (isFastPath(exponent, mantissa, negative, numDigits)) {
        let (<=) = WasmI64.lte
        let floatOpt = if exponent <= _MAX_EXPONENT_FAST_PATH {
          // normal fast path
          let (*) = WasmI64.mul
          let (/) = WasmI64.div
          let (<) = WasmI64.lt

          assert mantissa <= _MAX_MANTISSA_FAST_PATH

          let n = if (exponent < 0N) {
            mantissa / getPowers10FastPath(WasmI32.wrapI64(exponent * -1N))
          } else {
            mantissa * getPowers10FastPath(WasmI32.wrapI64(exponent))
          }
          if (negative) {
            Some(n * -1N)
          } else {
            Some(n)
          }
        } else {
          // disguised fast path
          let (-) = WasmI64.sub
          let (*) = WasmI64.mul
          let (>) = WasmI64.gt

          let shift = WasmI32.wrapI64(exponent - _MAX_EXPONENT_FAST_PATH)

          // TODO: Can't wrap with this multiplication, so we need to detect and error on overflow
          let mantissa = mantissa * WasmI64.extendI32U(getPowers10(shift))
          if mantissa > _MAX_MANTISSA_FAST_PATH {
            None
          } else {
            assert mantissa <= _MAX_MANTISSA_FAST_PATH

            let n = mantissa * getPowers10FastPath(WasmI32.wrapI64(_MAX_EXPONENT_FAST_PATH))
            if (negative) {
              Some(n * -1N)
            } else {
              Some(n)
            }
          }
        }
      }
      // Check if fast path worked
      match (floatOpt) {
        Some(n) => Ok(n)
        None => {
          // From Rust:
          // If significant digits were truncated, then we can have rounding error
          // only if `mantissa + 1` produces a different result. We also avoid
          // redundantly using the Eisel-Lemire algorithm if it was unable to
          // correctly round on the first pass.

          // let mut fp = compute_float::<F>(num.exponent, num.mantissa);
          // if num.many_digits && fp.e >= 0 && fp != compute_float::<F>(num.exponent, num.mantissa + 1) {
          //     fp.e = -1;
          // }
          // // Unable to correctly round the float using the Eisel-Lemire algorithm.
          // // Fallback to a slower, but always correct algorithm.
          // if fp.e < 0 {
          //     fp = parse_long_mantissa::<F>(s);
          // }

          // let mut float = biased_fp_to_float::<F>(fp);
          // if num.negative {
          //     float = -float;
          // }
          // Ok(float)
        }
      }
    },
    err => err
  }
}

@unsafe
export let rec parseInt = (string: String, radix: Number) => {
  let _CHAR_0 = 0x30n
  let _CHAR_B = 0x42n
  let _CHAR_b = 0x62n
  let _CHAR_O = 0x4fn
  let _CHAR_o = 0x6fn
  let _CHAR_X = 0x58n
  let _CHAR_x = 0x78n

  let _CHAR_A = 0x41n
  let _CHAR_a = 0x61n

  let _CHAR_UNDERSCORE = 0x5fn
  let _CHAR_MINUS = 0x2dn

  let _INT_MIN = -9223372036854775808N

  // Don't need to process Unicode length since if the string
  // contains non-ascii characters, it's not a valid integer
  let strLen = WasmI32.load(WasmI32.fromGrain(string), 4n)

  // Our pointer within the string we're parsing, offset by the
  // header
  let mut offset = WasmI32.fromGrain(string) + 8n

  let strEnd = offset + strLen

  let radix = WasmI32.fromGrain(radix)
  if (
    WasmI32.eqz(radix & Tags._GRAIN_NUMBER_TAG_MASK) ||
    radix < WasmI32.fromGrain(2) ||
    radix > WasmI32.fromGrain(36)
  ) {
    Err("Radix must be an integer between 2 and 36")
  } else if (WasmI32.eqz(strLen)) {
    Err("Invalid input")
  } else {
    let mut char = WasmI32.load8U(offset, 0n)

    let mut limit = WasmI64.add(_INT_MIN, 1N)

    // Check for a sign
    let mut negative = false
    if (char == _CHAR_MINUS) {
      negative = true
      offset += 1n
      limit = _INT_MIN
      char = WasmI32.load8U(offset, 0n)
    }

    let mut radix = WasmI64.extendI32S(radix >> 1n)

    // Check if we should override the supplied radix
    if (char == _CHAR_0 && strLen > 2n) {
      match (WasmI32.load8U(offset, 1n)) {
        c when c == _CHAR_B || c == _CHAR_b => {
          radix = 2N
          offset += 2n
        },
        c when c == _CHAR_O || c == _CHAR_o => {
          radix = 8N
          offset += 2n
        },
        c when c == _CHAR_X || c == _CHAR_x => {
          radix = 16N
          offset += 2n
        },
        _ => void,
      }
    }

    // We try to avoid allocating a BigInt if it's not needed
    let mut value = 0N
    let mut radixBigInt = 0n
    let mut valueBigInt = 0n
    let mut isBigInt = 0n

    // we use 0 to represent no error and 1 to represent an invalid input
    let mut error = 1n

    for (let mut i = offset; i < strEnd; i += 1n) {
      let char = WasmI32.load8U(i, 0n)

      // Ignore underscore characters
      if (char == _CHAR_UNDERSCORE) {
        continue
      }

      // We've seen at least one non-underscore character, so we'll consider
      // the input valid until we find out otherwise

      error = 0n

      let mut digit = 0n

      match (char) {
        c when c - _CHAR_0 < 10n => digit = char - _CHAR_0,
        c when c - _CHAR_A < 26n => digit = char - _CHAR_A + 10n,
        c when c - _CHAR_a < 26n => digit = char - _CHAR_a + 10n,
        _ => {
          error = 1n
          // invalid digit
          break
        },
      }

      if (digit >= WasmI32.wrapI64(radix)) {
        error = 1n
        // invalid digit
        break
      }

      let digit = WasmI64.extendI32U(digit)

      if (WasmI32.eqz(isBigInt)) {
        let prevValue = value
        value = WasmI64.mul(value, radix)
        // Check for overflow
        // 64-bit int min + 1
        if (WasmI64.ltS(value, WasmI64.add(limit, digit))) {
          // we overflowed. allocate BigInt and use instead
          isBigInt = 1n
          valueBigInt = BI.makeWrappedUint64(WasmI64.mul(prevValue, -1N))
          radixBigInt = BI.makeWrappedUint64(radix)
          let newvalue = BI.mul(valueBigInt, radixBigInt)
          Memory.decRef(valueBigInt)
          valueBigInt = newvalue
          let newvalue = BI.addInt(valueBigInt, digit)
          Memory.decRef(valueBigInt)
          valueBigInt = newvalue
        } else {
          // To quote the OpenJDK,
          // "Accumulating negatively avoids surprises near MAX_VALUE"
          // The minimum value of a 64-bit integer (-9223372036854775808) can't be
          // represented as a positive number because it would be larger than the
          // maximum 64-bit integer (9223372036854775807), so we'd be unable to
          // parse negatives as positives and multiply by the sign at the end.
          // Instead, we represent all positive numbers as negative numbers since
          // we have one unit more headroom.
          value = WasmI64.sub(value, digit)
        }
      } else {
        let newvalue = BI.mul(valueBigInt, radixBigInt)
        Memory.decRef(valueBigInt)
        valueBigInt = newvalue
        let newvalue = BI.addInt(valueBigInt, digit)
        Memory.decRef(valueBigInt)
        valueBigInt = newvalue
      }
    }

    match (error) {
      1n => {
        Err("Invalid digit in input")
      },
      _ => {
        if (WasmI32.eqz(isBigInt)) {
          let value = if (negative) value else WasmI64.mul(value, -1N)
          let number = WasmI32.toGrain(
            Memory.incRef(reducedInteger(value))
          ): Number
          Ok(number)
        } else {
          // BigInt number is accumulated in positive form
          if (negative) {
            let newvalue = BI.negate(valueBigInt)
            Memory.decRef(valueBigInt)
            Ok(WasmI32.toGrain(newvalue))
          } else {
            Ok(WasmI32.toGrain(valueBigInt))
          }
        }
      },
    }
  }
}
